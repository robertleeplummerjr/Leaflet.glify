{"version":3,"sources":["map-matrix.ts","canvas-overlay.ts","base.ts","color.ts","line-feature-vertices.ts","utils.ts","lines.ts","points.ts","shapes.ts","index.ts"],"names":[],"mappings":"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","file":"glify.js","sourceRoot":"../src","sourcesContent":["export class MapMatrix {\n  array: Float32Array;\n  constructor() {\n    this.array = new Float32Array(16);\n  }\n\n  setSize(width: number, height: number, offset?: number): this {\n    this.array.set([\n      2 / width, 0, 0, 0,\n      0, -2 / height, 0, 0,\n      0, 0, 0, 0,\n      -1, 1, 0, 1\n    ]);\n    return this;\n  }\n\n  translateMatrix(tx: number, ty: number): this {\n    const { array } = this;\n    // translation is in last column of matrix\n    array[12] += array[0] * tx + array[4] * ty;\n    array[13] += array[1] * tx + array[5] * ty;\n    array[14] += array[2] * tx + array[6] * ty;\n    array[15] += array[3] * tx + array[7] * ty;\n\n    return this;\n  }\n  scaleMatrix(scale: number) {\n    const { array } = this;\n    // scaling x and y, which is just scaling first two columns of matrix\n    array[0] *= scale;\n    array[1] *= scale;\n    array[2] *= scale;\n    array[3] *= scale;\n\n    array[4] *= scale;\n    array[5] *= scale;\n    array[6] *= scale;\n    array[7] *= scale;\n\n    return this;\n  }\n}\n","/*\noriginally taken from: http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js, added and customized as part of this lib because of need from library\n Generic  Canvas Overlay for leaflet,\n Stanislav Sumbera, April , 2014\n\n - added userDrawFunc that is called when Canvas need to be redrawn\n - added few useful params fro userDrawFunc callback\n - fixed resize map bug\n inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat\n */\n\nimport {\n  LatLngBounds,\n  Map,\n  Point,\n  Layer,\n  Util,\n  Browser,\n  Bounds,\n  DomUtil,\n  LatLng,\n  ZoomAnimEvent,\n} from 'leaflet';\n\nexport interface ICanvasOverlayDrawEvent {\n  canvas: HTMLCanvasElement;\n  bounds: LatLngBounds;\n  offset: Point;\n  scale: number;\n  size: Point;\n  zoomScale: number;\n  zoom: number;\n}\n\nexport interface IUserDrawFunc {\n  (event: ICanvasOverlayDrawEvent): void\n}\n\nexport class CanvasOverlay extends Layer {\n  _userDrawFunc: IUserDrawFunc;\n  _map: Map;\n  _redrawCallbacks: Function[];\n  canvas: HTMLCanvasElement;\n  _pane: string;\n\n  _frame?: number;\n\n  constructor(\n    userDrawFunc: IUserDrawFunc,\n    pane: string\n  ) {\n    super();\n    this._userDrawFunc = userDrawFunc;\n    this._frame = null;\n    this._redrawCallbacks = [];\n    this._pane = pane;\n  }\n\n  drawing(userDrawFunc): this {\n    this._userDrawFunc = userDrawFunc;\n    return this;\n  }\n\n  params(options): this {\n    Util.setOptions(this, options);\n    return this;\n  }\n\n  redraw(callback?) {\n    if (typeof callback === 'function') {\n      this._redrawCallbacks.push(callback);\n    }\n    if (this._frame === null) {\n      this._frame = Util.requestAnimFrame(this._redraw, this);\n    }\n    return this;\n  }\n\n  onAdd(map): this {\n    this._map = map;\n    this.canvas = this.canvas || document.createElement('canvas');\n\n    const size = map.getSize()\n      , animated = map.options.zoomAnimation && Browser.any3d\n      ;\n\n    this.canvas.width = size.x;\n    this.canvas.height = size.y;\n\n    this.canvas.className = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');\n\n    map._panes[this._pane].appendChild(this.canvas);\n\n    map.on('moveend', this._reset, this);\n    map.on('resize',  this._resize, this);\n\n    if (animated) {\n      map.on('zoomanim', Layer ? this._animateZoom : this._animateZoomNoLayer, this);\n    }\n\n    this._reset();\n    return this;\n  }\n\n  onRemove(map): this {\n    map.getPanes()[this._pane].removeChild(this.canvas);\n\n    map.off('moveend', this._reset, this);\n    map.off('resize', this._resize, this);\n\n    if (map.options.zoomAnimation && Browser.any3d) {\n      map.off('zoomanim', Layer ? this._animateZoom : this._animateZoomNoLayer, this);\n    }\n    return this;\n  }\n\n  addTo(map): this {\n    map.addLayer(this);\n    return this;\n  }\n\n  _resize(resizeEvent): void {\n    this.canvas.width  = resizeEvent.newSize.x;\n    this.canvas.height = resizeEvent.newSize.y;\n  }\n\n  _reset(): void {\n    const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n    DomUtil.setPosition(this.canvas, topLeft);\n    this._redraw();\n  }\n\n  _redraw(): void {\n    const { _map, canvas } = this\n      , size = _map.getSize()\n      , bounds = _map.getBounds()\n      , zoomScale = (size.x * 180) / (20037508.34  * (bounds.getEast() - bounds.getWest())) // resolution = 1/zoomScale\n      , zoom = _map.getZoom()\n      , topLeft = new LatLng(bounds.getNorth(), bounds.getWest())\n      , offset = this._unclampedProject(topLeft, 0)\n      ;\n\n    if (this._userDrawFunc) {\n      this._userDrawFunc({\n        bounds,\n        canvas,\n        offset,\n        scale: Math.pow(2, zoom),\n        size,\n        zoomScale,\n        zoom,\n      });\n    }\n\n    while (this._redrawCallbacks.length > 0) {\n      this._redrawCallbacks.shift()(this);\n    }\n\n    this._frame = null;\n  }\n\n  _animateZoom(e: ZoomAnimEvent): void {\n    const { _map } = this\n      , scale = _map.getZoomScale(e.zoom, _map.getZoom())\n      // @ts-ignore\n      , offset = this._unclampedLatLngBoundsToNewLayerBounds(_map.getBounds(), e.zoom, e.center).min\n      ;\n    DomUtil.setTransform(this.canvas, offset, scale);\n  }\n\n  _animateZoomNoLayer(e: ZoomAnimEvent): void {\n    const { _map } = this\n      , scale = _map.getZoomScale(e.zoom, _map.getZoom())\n      // @ts-ignore\n      , offset = _map._getCenterOffset(e.center)\n        ._multiplyBy(-scale)\n        // @ts-ignore\n        .subtract(_map._getMapPanePos())\n      ;\n    DomUtil.setTransform(this.canvas, offset, scale);\n  }\n\n  _unclampedProject(latlng: LatLng, zoom: number): Point {\n    // imported partly from https://github.com/Leaflet/Leaflet/blob/1ae785b73092fdb4b97e30f8789345e9f7c7c912/src/geo/projection/Projection.SphericalMercator.js#L21\n    // used because they clamp the latitude\n    const { crs } = this._map.options\n      // @ts-ignore\n      , { R } = crs.projection\n      , d = Math.PI / 180\n      , lat = latlng.lat\n      , sin = Math.sin(lat * d)\n      , projectedPoint = new Point(\n          // @ts-ignore\n          R * latlng.lng * d,\n          // @ts-ignore\n          R * Math.log((1 + sin) / (1 - sin)) / 2\n        )\n      , scale = crs.scale(zoom)\n      ;\n    // @ts-ignore\n    return crs.transformation._transform(projectedPoint, scale);\n  }\n\n  _unclampedLatLngBoundsToNewLayerBounds(latLngBounds: LatLngBounds, zoom: number, center: LatLng): Bounds {\n    // imported party from https://github.com/Leaflet/Leaflet/blob/84bc05bbb6e4acc41e6f89ff7421dd7c6520d256/src/map/Map.js#L1500\n    // used because it uses crs.projection.project, which clamp the latitude\n    // @ts-ignore\n    const topLeft = this._map._getNewPixelOrigin(center, zoom);\n    return new Bounds([\n      this._unclampedProject(latLngBounds.getSouthWest(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getNorthWest(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getSouthEast(), zoom).subtract(topLeft),\n      this._unclampedProject(latLngBounds.getNorthEast(), zoom).subtract(topLeft)\n    ]);\n  }\n}\n","import { IColor } from './color';\nimport { Map, Point } from 'leaflet';\nimport { MapMatrix } from './map-matrix';\nimport { CanvasOverlay, ICanvasOverlayDrawEvent } from './canvas-overlay';\n\nexport interface IShaderVariable {\n  type: 'FLOAT';\n  start?: number;\n  size: number;\n  normalize?: boolean;\n}\n\nexport interface IBaseSettings {\n  map: Map;\n  data: any;\n  shaderVariables?: {\n    [name: string]: IShaderVariable\n  }\n  longitudeKey?: number;\n  latitudeKey?: number;\n  setupClick?: (map: Map) => void;\n  setupHover?: (map: Map, hoverWait: number) => void;\n  vertexShaderSource?: (() => string) | string;\n  fragmentShaderSource?: (() => string) | string;\n  canvas?: HTMLCanvasElement;\n  click?: (e, feature, xy: Point) => boolean | void;\n  hover?: (e, feature, xy: Point) => boolean | void;\n  color?: ((featureIndex: number, feature: any) => IColor) | IColor;\n  className?: string;\n  opacity?: number;\n  preserveDrawingBuffer?: boolean;\n  hoverWait?: number;\n  pane?: string;\n}\n\nexport abstract class Base<T extends IBaseSettings = IBaseSettings> {\n  bytes: number;\n  active: boolean;\n  fragmentShader: any;\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  layer: CanvasOverlay;\n  mapMatrix: MapMatrix;\n  matrix: WebGLUniformLocation;\n  program: WebGLProgram;\n  settings: T;\n  vertexShader: any;\n  vertices: any;\n  vertexLines: any;\n\n  buffers: { [name: string]: WebGLBuffer } = {};\n  attributeLocations: { [name: string]: number } = {};\n  uniformLocations: { [name: string]: WebGLUniformLocation } = {};\n\n  abstract render(): this;\n\n  constructor(settings: T) {\n    if (!settings.pane) settings.pane = \"overlayPane\";\n    this.mapMatrix = new MapMatrix();\n    this.active = true;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.program = null;\n    this.matrix = null;\n    this.vertices = null;\n    this.vertexLines = null;\n    const preserveDrawingBuffer = Boolean(settings.preserveDrawingBuffer);\n    const layer = this.layer = new CanvasOverlay((context) => {\n      return this.drawOnCanvas(context);\n    }, settings.pane).addTo(settings.map);\n    const canvas = this.canvas = layer.canvas;\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    canvas.style.position = 'absolute';\n    if (settings.className) {\n      canvas.className += ' ' + settings.className;\n    }\n    this.gl = (\n      canvas.getContext('webgl2', { preserveDrawingBuffer })\n      || canvas.getContext('webgl', { preserveDrawingBuffer })\n      || canvas.getContext('experimental-webgl', { preserveDrawingBuffer })) as WebGLRenderingContext;\n  }\n\n  abstract drawOnCanvas(context: ICanvasOverlayDrawEvent): this;\n\n  attachShaderVariables(byteCount: number): this {\n    let variableCount = this.getShaderVariableCount();\n    if (variableCount === 0) {\n      return this;\n    }\n    const { gl, settings } = this;\n    const { shaderVariables } = settings;\n    let offset = 0;\n    for (const name in shaderVariables) {\n      if (!shaderVariables.hasOwnProperty(name)) continue;\n      const shaderVariable = shaderVariables[name];\n      const loc = this.getAttributeLocation(name);\n      if (loc < 0) {\n        throw new Error('shader variable ' + name + ' not found');\n      }\n      gl.vertexAttribPointer(\n        loc,\n        shaderVariable.size,\n        gl[shaderVariable.type],\n        !!shaderVariable.normalize,\n        this.bytes * byteCount,\n        offset * byteCount\n      );\n      offset += shaderVariable.size;\n      gl.enableVertexAttribArray(loc);\n    }\n\n    return this;\n  }\n\n  getShaderVariableCount(): number {\n    return Object.keys(this.settings.shaderVariables).length;\n  }\n\n  setData(data): this {\n    this.settings.data = data;\n    return this;\n  }\n\n  setup(): this {\n    const settings = this.settings;\n    if (settings.click) {\n      settings.setupClick(settings.map);\n    }\n    if (settings.hover) {\n      settings.setupHover(settings.map, settings.hoverWait);\n    }\n\n    return this\n      .setupVertexShader()\n      .setupFragmentShader()\n      .setupProgram();\n  }\n\n  setupVertexShader(): this {\n    const gl = this.gl\n      , settings = this.settings\n      , vertexShaderSource = typeof settings.vertexShaderSource === 'function'\n          ? settings.vertexShaderSource()\n          : settings.vertexShaderSource\n      , vertexShader = gl.createShader(gl.VERTEX_SHADER)\n      ;\n\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n\n    this.vertexShader = vertexShader;\n\n    return this;\n  }\n\n  setupFragmentShader(): this {\n    const gl = this.gl\n      , settings = this.settings\n      , fragmentShaderSource = typeof settings.fragmentShaderSource === 'function'\n          ? settings.fragmentShaderSource()\n          : settings.fragmentShaderSource\n      , fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n      ;\n\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n\n    this.fragmentShader = fragmentShader;\n\n    return this;\n  }\n\n  setupProgram(): this {\n    // link shaders to create our program\n    const gl = this.gl\n      , program = gl.createProgram()\n      ;\n\n    gl.attachShader(program, this.vertexShader);\n    gl.attachShader(program, this.fragmentShader);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n\n    this.program = program;\n\n    return this;\n  }\n\n  addTo(map): this {\n    this.layer.addTo(map || this.settings.map);\n    this.active = true;\n    return this.render();\n  }\n\n  remove(indices?: number | number[]): this {\n    if (indices === undefined) {\n      this.settings.map.removeLayer(this.layer as any);\n      this.active = false;\n    } else {\n      const feat = this.settings.data.features || this.settings.data;\n      indices = (indices instanceof Array) ? indices : [indices];\n      if (typeof indices === \"number\") indices = [indices];\n      indices.sort().reverse();\n      indices.forEach((index: number) => {feat.splice(index, 1)});\n      this.render();\n    }\n    return this;\n  }\n\n  update(data: any, index: number): this {\n    const feat = this.settings.data.features || this.settings.data;\n    feat[index] = data;\n    this.render();\n    return this;\n  }\n\n  getBuffer(name: string): WebGLBuffer {\n    if (!this.buffers[name]) {\n      this.buffers[name] = this.gl.createBuffer();\n    }\n    return this.buffers[name];\n  }\n\n  getAttributeLocation(name: string): number {\n    if (this.attributeLocations[name] !== undefined) {\n      return this.attributeLocations[name];\n    }\n    return this.attributeLocations[name] = this.gl.getAttribLocation(this.program, name);\n  }\n\n  getUniformLocation(name: string): WebGLUniformLocation {\n    if (this.uniformLocations[name] !== undefined) {\n      return this.uniformLocations[name];\n    }\n    return this.uniformLocations[name] = this.gl.getUniformLocation(this.program, name);\n  }\n\n}\n","export interface IColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nconst green: IColor = {r: 0, g: 1, b: 0, a: 1};\nconst red: IColor = {r: 1, g: 0, b: 0, a: 1};\nconst blue: IColor = {r: 0, g: 0, b: 1, a: 1};\nconst teal: IColor = {r: 0, g: 1, b: 1, a: 1};\nconst yellow: IColor = {r: 1, g: 1, b: 0, a: 1};\n\nconst white: IColor = {r: 1, g: 1, b: 1, a: 1};\nconst black: IColor = {r: 0, g: 0, b: 0, a: 1};\n\nconst gray: IColor = {r: 0.5, g: 0.5, b: 0.5, a: 1};\n\nexport class Color {\n  static green;\n  static red;\n  static blue;\n  static teal;\n  static yellow;\n  static white;\n  static black;\n  static gray;\n  static get grey() {\n    return gray;\n  }\n\n  static fromHex(hex): IColor | null {\n    if (hex.length < 6) return null;\n    hex = hex.toLowerCase();\n\n    if (hex[0] === '#') {\n      hex = hex.substring(1, hex.length);\n    }\n\n    const r = parseInt(hex[0] + hex[1], 16)\n      , g = parseInt(hex[2] + hex[3], 16)\n      , b = parseInt(hex[4] + hex[5], 16)\n      ;\n    return { r: r / 255, g: g / 255, b: b / 255, a: 1 };\n  }\n\n  static random(): IColor {\n    return {\n      r: Math.random(),\n      g: Math.random(),\n      b: Math.random(),\n      a: Math.random(),\n    };\n  }\n\n  static pallet(): IColor {\n    switch (Math.round(Math.random() * 4)) {\n      case 0:\n        return green;\n      case 1:\n        return red;\n      case 2:\n        return blue;\n      case 3:\n        return teal;\n      case 4:\n        return yellow;\n    }\n  }\n}\n","import { LatLng } from 'leaflet';\nimport { IColor } from './color';\nimport { IPixel } from './pixel';\n\ninterface ILineFeatureVerticesSettings {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  color: IColor;\n  latitudeKey?: number;\n  longitudeKey?: number;\n  opacity: number;\n}\n\nexport class LineFeatureVertices {\n  settings: ILineFeatureVerticesSettings;\n  vertexCount: number;\n  array: number[];\n  length: number;\n\n  constructor(settings: ILineFeatureVerticesSettings) {\n    this.settings = settings;\n    this.vertexCount = 0;\n    this.array = [];\n    this.length = 0;\n  }\n\n  fillFromCoordinates(coordinates) {\n    const { color, opacity, project, latitudeKey, longitudeKey } = this.settings;\n    for (let i = 0; i < coordinates.length; i++) {\n      if (Array.isArray(coordinates[i][0])) {\n        this.fillFromCoordinates(coordinates[i]);\n        continue;\n      }\n      const pixel = project(\n        new LatLng(\n          coordinates[i][latitudeKey],\n          coordinates[i][longitudeKey]\n        ), 0);\n      this.push(pixel.x, pixel.y, color.r, color.g, color.b, color.a || opacity);\n      if (i !== 0 && i !== coordinates.length - 1) {\n        this.vertexCount += 1;\n      }\n      this.vertexCount += 1;\n    }\n  }\n\n  push(...args) {\n    this.array.push(...args);\n    this.length = this.array.length;\n  }\n}\n","import { LatLng, Map } from 'leaflet';\n\nexport function defaults(userSettings, defaults) {\n  const settings = {};\n\n  for (const i in defaults) {\n    if (!defaults.hasOwnProperty(i)) continue;\n    settings[i] = (userSettings.hasOwnProperty(i) ? userSettings[i] : defaults[i]);\n  }\n\n  return settings;\n}\n\n// -- converts latlon to pixels at zoom level 0 (for 256x256 tile size) , inverts y coord )\n// -- source : http://build-failed.blogspot.cz/2013/02/displaying-webgl-data-on-google-maps.html\nexport function latLonToPixel(latitude, longitude) {\n  const pi180 = Math.PI / 180.0,\n    pi4 = Math.PI * 4,\n    sinLatitude = Math.sin(latitude * pi180),\n    pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi4)) * 256,\n    pixelX = ((longitude + 180) / 360) * 256;\n\n  return {x: pixelX, y: pixelY};\n}\n\nexport function pointInCircle(centerPoint, checkPoint, radius) {\n  const distanceSquared = (centerPoint.x - checkPoint.x) * (centerPoint.x - checkPoint.x) + (centerPoint.y - checkPoint.y) * (centerPoint.y - checkPoint.y);\n  return distanceSquared <= radius * radius;\n}\n\nexport function pDistance(x, y, x1, y1, x2, y2): number {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) //in case of 0 length line\n    param = dot / len_sq;\n\n  let xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  let dx = x - xx;\n  let dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function vectorDistance(dx: number, dy: number): number {\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function locationDistance(location1: LatLng, location2: LatLng, map: Map): number {\n  const point1 = map.latLngToLayerPoint(location1)\n    , point2 = map.latLngToLayerPoint(location2)\n    , dx = point1.x - point2.x\n    , dy = point1.y - point2.y\n  ;\n  return vectorDistance(dx, dy);\n}\n\nexport function debugPoint(containerPoint) {\n  const el = document.createElement('div')\n    , s = el.style\n    , x = containerPoint.x\n    , y = containerPoint.y\n  ;\n\n  s.left = x + 'px';\n  s.top = y + 'px';\n  s.width = '10px';\n  s.height = '10px';\n  s.position = 'absolute';\n  s.backgroundColor = '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n\n  document.body.appendChild(el);\n}\n\nexport function debounce(func, wait: number, immediate: Boolean) {\n  let timeout;\n  return function() {\n      let context = this, args = arguments;\n      let later = function() {\n          timeout = null;\n          if (!immediate) func.apply(context, args);\n      };\n      let callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n  };\n}\n\nexport function inBounds(e, bounds) {\n  let cond = ((bounds._northEast.lat > e.lat) && (e.lat > bounds._southWest.lat) &&\n   (bounds._northEast.lng > e.lng) && (e.lng > bounds._southWest.lng));\n  return cond;\n}\n","import { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { Map, LeafletMouseEvent, geoJSON } from 'leaflet';\nimport { LineFeatureVertices } from './line-feature-vertices';\nimport { pDistance, inBounds } from './utils';\n\nexport interface ILinesSettings extends IBaseSettings {\n  weight: ((i: number, feature: any) => number) | number;\n  sensitivity?: number;\n  sensitivityHover?: number;\n}\n\nconst defaults: ILinesSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  setupHover: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  hover: null,\n  color: Color.random,\n  className: '',\n  opacity: 0.5,\n  weight: 2,\n  sensitivity: 0.1,\n  sensitivityHover: 0.03,\n  shaderVariables: {\n    vertex: {\n      type: 'FLOAT',\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 4\n    }\n  }\n};\n\nexport class Lines extends Base<ILinesSettings> {\n  static defaults = defaults;\n  static instances: Lines[] = [];\n\n  bytes = 6;\n  allVertices: number[];\n  vertices: LineFeatureVertices[];\n  aPointSize: number;\n\n  constructor(settings: ILinesSettings) {\n    super(settings);\n    Lines.instances.push(this);\n    this.settings = { ...Lines.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n    this.allVertices = [];\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    const { canvas, gl, layer, vertices, settings, mapMatrix } = this\n      , vertexBuffer = this.getBuffer('vertex')\n      , vertex = this.getAttributeLocation('vertex')\n      , opacity = this.getUniformLocation('opacity')\n      ;\n\n    gl.uniform1f(opacity, settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    /*\n    Transforming lines according to the rule:\n    1. Take one line (single feature)\n    [[0,0],[1,1],[2,2]]\n    2. Split the line in segments, duplicating all coordinates except first and last one\n    [[0,0],[1,1],[2,2]] => [[0,0],[1,1],[1,1],[2,2]]\n    3. Do this for all lines and put all coordinates in array\n    */\n    let size = vertices.length;\n    const allVertices = [];\n    for (let i = 0; i < size; i++) {\n      const vertexArray = vertices[i].array;\n      const length = vertexArray.length / this.bytes;\n      for (let j = 0; j < length; j++) {\n        const vertexIndex = j * this.bytes;\n        if (j !== 0 && j !== (length - 1)) {\n          allVertices.push(\n            vertexArray[vertexIndex],\n            vertexArray[vertexIndex + 1],\n            vertexArray[vertexIndex + 2],\n            vertexArray[vertexIndex + 3],\n            vertexArray[vertexIndex + 4],\n            vertexArray[vertexIndex + 5]\n          );\n        }\n        allVertices.push(\n          vertexArray[vertexIndex],\n          vertexArray[vertexIndex + 1],\n          vertexArray[vertexIndex + 2],\n          vertexArray[vertexIndex + 3],\n          vertexArray[vertexIndex + 4],\n          vertexArray[vertexIndex + 5]\n        );\n      }\n    }\n\n    this.allVertices = allVertices;\n\n    const vertArray = new Float32Array(allVertices);\n    size = vertArray.BYTES_PER_ELEMENT;\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * this.bytes, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = this.getUniformLocation('matrix');\n    this.aPointSize = this.getAttributeLocation('pointSize');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    mapMatrix.setSize(canvas.width, canvas.height);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n    this.attachShaderVariables(size);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.allVertices = [];\n    this.vertices = [];\n\n    const vertices = this.vertices\n      , settings = this.settings\n      , data = settings.data\n      , features = data.features\n      , map = settings.map\n      , latitudeKey = settings.latitudeKey\n      , longitudeKey = settings.longitudeKey\n      , featureMax = features.length\n      ;\n\n    let feature\n      , { color, opacity } = settings\n      , colorFn: (i: number, feature: any) => IColor\n      , chosenColor: IColor\n      , featureIndex = 0\n      ;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      //use colorFn function here if it exists\n      if (colorFn) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as IColor;\n      }\n\n      const featureVertices = new LineFeatureVertices({\n        project: map.project.bind(map),\n        latitudeKey,\n        longitudeKey,\n        color: chosenColor,\n        opacity,\n      });\n      featureVertices.fillFromCoordinates(feature.geometry.coordinates);\n      vertices.push(featureVertices);\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { gl, settings, canvas, mapMatrix, matrix, allVertices, vertices } = this\n      , { weight } = settings\n      , { scale, offset, zoom } = e\n      , pointSize = Math.max(zoom - 4.0, 4.0)\n      ;\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.vertexAttrib1f(this.aPointSize, pointSize);\n    mapMatrix\n      .setSize(canvas.width, canvas.height)\n      .scaleMatrix(scale);\n    if (zoom > 18) {\n      mapMatrix.translateMatrix(-offset.x, -offset.y);\n      // -- attach matrix value to 'mapMatrix' uniform in shader\n      gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n      gl.drawArrays(gl.LINES, 0, allVertices.length / this.bytes);\n    } else if (typeof weight === 'number') {\n      // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n      for (let yOffset = -weight; yOffset < weight; yOffset += 0.5) {\n        for (let xOffset = -weight; xOffset < weight; xOffset += 0.5) {\n          // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n          mapMatrix.translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n          // -- attach matrix value to 'mapMatrix' uniform in shader\n          gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n\n          gl.drawArrays(gl.LINES, 0, allVertices.length / this.bytes);\n        }\n      }\n    } else if (typeof weight === 'function') {\n      let allVertexCount = 0;\n      const features = settings.data.features;\n      for (let i = 0; i < vertices.length; i++) {\n        const featureVertices = vertices[i];\n        const vertexCount = featureVertices.vertexCount;\n        const weightValue = weight(i, features[i]);\n        // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n        for (let yOffset = -weightValue; yOffset < weightValue; yOffset += 0.5) {\n          for (let xOffset = -weightValue; xOffset < weightValue; xOffset += 0.5) {\n            // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n            mapMatrix.translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n            // -- attach matrix value to 'mapMatrix' uniform in shader\n            gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n            gl.drawArrays(gl.LINES, allVertexCount, vertexCount);\n          }\n        }\n        allVertexCount += vertexCount;\n      }\n    }\n    return this;\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): void {\n    let foundFeature = false\n      , instance = null\n      , sensitivity\n      , settings\n      ;\n    Lines.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      sensitivity = settings.sensitivity;\n      const {latitudeKey, longitudeKey } = settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      settings.data.features.map(feature => {\n        for (let i = 1; i < feature.geometry.coordinates.length; i++) {\n          let distance = pDistance(e.latlng.lng, e.latlng.lat,\n            feature.geometry.coordinates[i - 1][longitudeKey], feature.geometry.coordinates[i - 1][latitudeKey],\n            feature.geometry.coordinates[i][longitudeKey], feature.geometry.coordinates[i][latitudeKey]);\n          if (distance < sensitivity) {\n            sensitivity = distance;\n            foundFeature = feature;\n            instance = _instance;\n          }\n        }\n      });\n    });\n\n    if (instance) {\n      instance.settings.click(e, foundFeature);\n    } else {\n      return;\n    }\n  }\n\n  static tryHover(e: LeafletMouseEvent, map: Map): void {\n    let foundFeature = false\n      , instance = null\n      , settings\n      , sensitivityHover\n      ;\n    Lines.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      sensitivityHover = settings.sensitivityHover;\n      const {latitudeKey, longitudeKey } = settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.hover) return;\n      // Check if e.latlng is inside the bbox of the features\n      let bounds = geoJSON(settings.data.features).getBounds();\n      \n      if (inBounds(e.latlng, bounds)) {\n        settings.data.features.map(feature => {\n          for (let i = 1; i < feature.geometry.coordinates.length; i++) {\n            let distance = pDistance(e.latlng.lng,\n                                    e.latlng.lat,\n                                    feature.geometry.coordinates[i - 1][longitudeKey],\n                                    feature.geometry.coordinates[i - 1][latitudeKey],\n                                    feature.geometry.coordinates[i][longitudeKey],\n                                    feature.geometry.coordinates[i][latitudeKey]);\n\n            if (distance < sensitivityHover) {\n              sensitivityHover = distance;\n              foundFeature = feature;\n              instance = _instance;\n            }\n          }\n        });\n      }\n    })\n\n    if (instance) {\n      instance.settings.hover(e, foundFeature);\n    } else {\n      return;\n    }\n  }\n}\n","import { Feature, Point as GeoPoint } from 'geojson';\n\nimport { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { LeafletMouseEvent, Map, Point, LatLng, Projection } from 'leaflet';\nimport { IPixel } from './pixel';\nimport { locationDistance, pointInCircle } from './utils';\n\nexport interface IPointsSettings extends IBaseSettings {\n  size: ((i: number, latLng: LatLng) => number) | number;\n  eachVertex?: (this: Points, latLng: LatLng, pixel: IPixel, color: IColor) => void;\n  sensitivity?: number;\n  sensitivityHover?: number;\n}\n\nconst defaults: IPointsSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  setupHover: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  eachVertex: null,\n  click: null,\n  hover: null,\n  color: Color.random,\n  opacity: 0.8,\n  size: null,\n  className: '',\n  sensitivity: 2,\n  sensitivityHover: 0.03,\n  shaderVariables: {\n    vertex: {\n      type: 'FLOAT',\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 4,\n    },\n    pointSize: {\n      type: 'FLOAT',\n      start: 6,\n      size: 1,\n    },\n  }\n};\n\nexport interface IPointLookup {\n  latLng: LatLng;\n  pixel: IPixel;\n  chosenColor: IColor;\n  chosenSize: number;\n  key: string;\n  feature?: any;\n}\n\nexport class Points extends Base<IPointsSettings> {\n  static instances: Points[] = [];\n  static defaults = defaults;\n  static maps = [];\n  bytes = 7;\n  latLngLookup: {\n    [key: string]: IPointLookup[];\n  };\n  allLatLngLookup: IPointLookup[];\n  vertices: number[];\n  typedVertices: Float32Array;\n  dataFormat: 'Array' | 'GeoJson.FeatureCollection';\n  constructor(settings) {\n    super(settings);\n    Points.instances.push(this);\n    this.settings = {...Points.defaults, ...settings};\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n\n    const { data } = this.settings;\n    if (Array.isArray(data)) {\n      this.dataFormat = 'Array';\n    } else if (data.type === 'FeatureCollection') {\n      this.dataFormat = 'GeoJson.FeatureCollection';\n    } else {\n      throw new Error('unhandled data type. Supported types are Array and GeoJson.FeatureCollection');\n    }\n\n    // @ts-ignore\n    if (this.settings.map.options.crs.projection.project !== Projection.SphericalMercator.project) {\n      console.warn('layer designed for SphericalMercator, alternate detected');\n    }\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    //look up the locations for the inputs to our shaders.\n    const { gl, canvas, layer, vertices, mapMatrix } = this\n      , matrix = this.matrix = this.getUniformLocation('matrix')\n      , verticesBuffer = this.getBuffer('vertices')\n      , verticesTypedArray = this.typedVertices = new Float32Array(vertices)\n      , byteCount = verticesTypedArray.BYTES_PER_ELEMENT\n      ;\n\n    //set the matrix to some that makes 1 unit 1 pixel.\n    mapMatrix.setSize(canvas.width, canvas.height);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, verticesTypedArray, gl.STATIC_DRAW);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  getPointLookup(key: string): IPointLookup[] {\n    return (this.latLngLookup[key] || (this.latLngLookup[key] = []));\n  }\n\n  addLookup(lookup: IPointLookup): this {\n    this.getPointLookup(lookup.key).push(lookup);\n    this.allLatLngLookup.push(lookup);\n    return this;\n  }\n\n  resetVertices(): this {\n    //empty vertices and repopulate\n    this.latLngLookup = {};\n    this.allLatLngLookup = [];\n    this.vertices = [];\n\n    const { vertices, settings } = this\n      , { latitudeKey, longitudeKey, data, map, eachVertex, color, size, opacity } = settings\n      ;\n    let colorFn: (i: number, latLng: LatLng | any) => IColor\n      , chosenColor: IColor\n      , chosenSize: number\n      , sizeFn\n      , latLng\n      , pixel: Point\n      , key\n      ;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color as (i: number, latLng: LatLng) => IColor;\n    }\n\n    if (!size) {\n      throw new Error('size is not properly defined');\n    } else if (typeof size === 'function') {\n      sizeFn = size;\n    }\n\n    if (this.dataFormat === 'Array') {\n      const max = data.length;\n      for (let i = 0; i < max; i++) {\n        latLng = data[i];\n        key = latLng[latitudeKey].toFixed(2) + 'x' + latLng[longitudeKey].toFixed(2);\n        pixel = map.project(new LatLng(latLng[latitudeKey], latLng[longitudeKey]), 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, latLng) as IColor;\n        } else {\n          chosenColor = color as IColor;\n        }\n\n        chosenColor = { ...chosenColor, a: chosenColor.a || opacity };\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng) as number;\n        } else {\n          chosenSize = size as number;\n        }\n\n        vertices.push(\n          // vertex\n          pixel.x,\n          pixel.y,\n\n          // color\n          chosenColor.r,\n          chosenColor.g,\n          chosenColor.b,\n          chosenColor.a,\n\n          // size\n          chosenSize\n        );\n        this.addLookup({\n          latLng,\n          key,\n          pixel,\n          chosenColor,\n          chosenSize\n        });\n        if (eachVertex) {\n          eachVertex.call(this, latLng, pixel, chosenSize);\n        }\n      }\n    } else if (this.dataFormat === 'GeoJson.FeatureCollection') {\n      const max = data.features.length;\n      for (let i = 0; i < max; i++) {\n        const feature = data.features[i] as Feature<GeoPoint>;\n        latLng = feature.geometry.coordinates;\n        key = latLng[latitudeKey].toFixed(2) + 'x' + latLng[longitudeKey].toFixed(2);\n        pixel = map.project(new LatLng(latLng[latitudeKey], latLng[longitudeKey]), 0);\n\n        if (colorFn) {\n          chosenColor = colorFn(i, feature) as IColor;\n        } else {\n          chosenColor = color as IColor;\n        }\n\n        chosenColor = { ...chosenColor, a: chosenColor.a || opacity };\n\n        if (sizeFn) {\n          chosenSize = sizeFn(i, latLng) as number;\n        } else {\n          chosenSize = size as number;\n        }\n\n        vertices.push(\n          // vertex\n          pixel.x,\n          pixel.y,\n\n          // color\n          chosenColor.r,\n          chosenColor.g,\n          chosenColor.b,\n          chosenColor.a,\n\n          // size\n          chosenSize\n        );\n        this.addLookup({\n          latLng,\n          key,\n          pixel,\n          chosenColor,\n          chosenSize,\n          feature\n        });\n        if (eachVertex) {\n          eachVertex.call(this, latLng, pixel, chosenSize);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  pointSize(pointIndex): number {\n    const { map, size } = this.settings\n      , pointSize = typeof size === 'function' ? size(pointIndex, null) : size\n      // -- Scale to current zoom\n      , zoom = map.getZoom()\n      ;\n\n    return pointSize === null ? Math.max(zoom - 4.0, 1.0) : pointSize;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { gl, canvas, settings, mapMatrix, matrix } = this\n      , { map } = settings\n      , { offset } = e\n      , zoom = map.getZoom()\n      , scale = Math.pow(2, zoom)\n      ;\n\n    //set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .setSize(canvas.width, canvas.height)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.POINTS, 0, this.allLatLngLookup.length);\n\n    return this;\n  }\n\n  lookup(coords: LatLng): IPointLookup {\n    const xMax: number = coords.lat + 0.03\n      , yMax: number = coords.lng + 0.03\n      , matches: IPointLookup[] = []\n      ;\n    let x = coords.lat - 0.03\n      , y: number\n      , foundI: number\n      , foundMax: number\n      , found: IPointLookup[]\n      , key: string\n      ;\n\n    for (; x <= xMax; x += 0.01) {\n      y = coords.lng - 0.03;\n      for (; y <= yMax; y += 0.01) {\n        key = x.toFixed(2) + 'x' + y.toFixed(2);\n        found = this.latLngLookup[key];\n        if (found) {\n          foundI = 0;\n          foundMax = found.length;\n          for (; foundI < foundMax; foundI++) {\n            matches.push(found[foundI]);\n          }\n        }\n      }\n    }\n\n    const { map } = this.settings;\n\n    //try matches first, if it is empty, try the data, and hope it isn't too big\n    return Points.closest(\n      coords,\n      matches.length > 0\n        ? matches\n        : this.allLatLngLookup,\n      map\n    );\n  }\n\n  static closest(targetLocation: LatLng, points: IPointLookup[], map: Map): IPointLookup {\n    if (points.length < 1) return null;\n    return points.reduce((prev, curr) => {\n      const prevDistance = locationDistance(targetLocation, prev.latLng, map)\n        , currDistance = locationDistance(targetLocation, curr.latLng, map)\n        ;\n      return (prevDistance < currDistance) ? prev : curr;\n    });\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): boolean | void {\n    const closestFromEach: IPointLookup[] = []\n      , instancesLookup = {}\n      ;\n    let result\n      , settings: IPointsSettings\n      , instance: Points\n      , pointLookup: IPointLookup\n      , xy: Point\n      , found: IPointLookup\n      , foundLatLng\n      ;\n\n    Points.instances.forEach((_instance) => {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      pointLookup = _instance.lookup(e.latlng);\n      instancesLookup[pointLookup.key] = _instance;\n      closestFromEach.push(pointLookup);\n    });\n\n    if (closestFromEach.length < 1) return;\n    if (!settings) return;\n\n    found = this.closest(e.latlng, closestFromEach, map);\n\n    if (found === null) return;\n\n    instance = instancesLookup[found.key];\n    if (!instance) return;\n    const { latitudeKey, longitudeKey, sensitivity, click } = instance.settings;\n\n    foundLatLng = new LatLng(found.latLng[latitudeKey], found.latLng[longitudeKey]);\n    xy = map.latLngToLayerPoint(foundLatLng);\n\n    if (pointInCircle(\n      xy,\n      e.layerPoint,\n      found.chosenSize * sensitivity\n    )) {\n      result = click(e, found.feature || found.latLng, xy);\n      return result !== undefined ? result : true;\n    }\n  }\n\n  static tryHover(e: LeafletMouseEvent, map: Map): boolean | void {\n    const closestFromEach: IPointLookup[] = []\n      , instancesLookup = {}\n      ;\n    let result\n      , settings: IPointsSettings\n      , instance: Points\n      , pointLookup: IPointLookup\n      , xy: Point\n      , found: IPointLookup\n      , foundLatLng\n      ;\n\n    Points.instances.forEach((_instance) => {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.hover) return;\n\n      pointLookup = _instance.lookup(e.latlng);\n      instancesLookup[pointLookup.key] = _instance;\n      closestFromEach.push(pointLookup);\n    });\n\n    if (closestFromEach.length < 1) return;\n    if (!settings) return;\n\n    found = this.closest(e.latlng, closestFromEach, map);\n\n    if (found === null) return;\n\n    instance = instancesLookup[found.key];\n    if (!instance) return;\n    const { latitudeKey, longitudeKey, sensitivityHover, hover } = instance.settings;\n\n    foundLatLng = new LatLng(found.latLng[latitudeKey], found.latLng[longitudeKey]);\n    xy = map.latLngToLayerPoint(foundLatLng);\n\n    if (pointInCircle(\n      xy,\n      e.layerPoint,\n      found.chosenSize * sensitivityHover\n    )) {\n      result = hover(e, found.feature || found.latLng, xy);\n      return result !== undefined ? result : true;\n    }\n  }\n}\n","import earcut from 'earcut';\nimport geojsonFlatten from 'geojson-flatten';\nimport PolygonLookup from 'polygon-lookup';\n\nimport { Base, IBaseSettings } from './base';\nimport { ICanvasOverlayDrawEvent } from './canvas-overlay';\nimport { Color, IColor } from './color';\nimport { LatLng, LeafletMouseEvent, Map} from 'leaflet';\nimport { latLonToPixel } from './utils';\n\nexport interface IShapeSettings extends IBaseSettings {\n  border?: boolean\n}\n\nexport const defaults: IShapeSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  setupClick: null,\n  setupHover: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  hover: null,\n  color: Color.random,\n  className: '',\n  opacity: 0.5,\n  shaderVariables: {\n    vertex: {\n      type: 'FLOAT',\n      start: 0,\n      size: 2,\n    },\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 4\n    }\n  },\n  border: false\n};\n\nexport class Shapes extends Base<IShapeSettings> {\n  static instances: Shapes[] = [];\n  static defaults = defaults;\n  static maps: Map[];\n  bytes = 6;\n  polygonLookup: PolygonLookup;\n\n  constructor(settings: IShapeSettings) {\n    super(settings);\n    Shapes.instances.push(this);\n    this.settings = { ...Shapes.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n    this.polygonLookup = null;\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n    // triangles or point count\n\n    const { canvas, gl, layer, vertices, mapMatrix } = this\n      , vertexBuffer = this.getBuffer('vertex')\n      , vertArray = new Float32Array(vertices)\n      , byteCount = vertArray.BYTES_PER_ELEMENT\n      , vertex = this.getAttributeLocation('vertex')\n      ;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, byteCount * this.bytes, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = this.getUniformLocation('matrix');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mapMatrix.setSize(canvas.width, canvas.height)\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n    this.attachShaderVariables(byteCount);\n\n    layer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.vertices = [];\n    this.vertexLines = [];\n    this.polygonLookup = new PolygonLookup();\n\n    const { vertices, vertexLines, polygonLookup, settings } = this\n      , data = settings.data as any\n      ;\n\n    let pixel\n      , index\n      , features\n      , feature\n      , { color, opacity } = settings\n      , colorFn: (i: number, feature: any) => IColor\n      , chosenColor: IColor\n      , coordinates\n      , featureIndex = 0\n      , featureMax\n      , triangles\n      , indices\n      , flat\n      , dim\n      ;\n\n    switch (data.type) {\n      case 'Feature':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [data]\n        });\n        features = geojsonFlatten(data);\n        break;\n      case 'MultiPolygon':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [{\n            type: 'Feature',\n            properties: { id: 'bar' },\n            geometry: { coordinates: data.coordinates }\n          }]\n        });\n        features = geojsonFlatten(data);\n        break;\n      default:\n        polygonLookup.loadFeatureCollection(data);\n        features = data.features;\n    }\n    featureMax = features.length;\n\n    if (!color) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      triangles = [];\n\n      //use colorFn function here if it exists\n      if (colorFn) {\n        chosenColor = colorFn(featureIndex, feature);\n      } else {\n        chosenColor = color as IColor;\n      }\n\n      coordinates = (feature.geometry || feature).coordinates;\n      flat = earcut.flatten(coordinates);\n      indices = earcut(flat.vertices, flat.holes, flat.dimensions);\n      dim = coordinates[0][0].length;\n      for (let i = 0, iMax = indices.length; i < iMax; i++) {\n        index = indices[i];\n        if (typeof flat.vertices[0] === 'number') {\n          triangles.push(flat.vertices[index * dim + settings.longitudeKey], flat.vertices[index * dim + settings.latitudeKey]);\n        } else {\n          throw new Error('unhandled polygon');\n        }\n      }\n\n      for (let i = 0, iMax = triangles.length; i < iMax; i) {\n        pixel = settings.map.project(new LatLng(triangles[i++], triangles[i++]), 0);\n        vertices.push(pixel.x, pixel.y, chosenColor.r, chosenColor.g, chosenColor.b, chosenColor.a || opacity);\n      }\n\n      if (settings.border) {\n        let lines = [];\n        for (let i = 1, iMax = flat.vertices.length; i < iMax; i=i+2) {\n          lines.push(flat.vertices[i], flat.vertices[i-1]);\n          lines.push(flat.vertices[i+2], flat.vertices[i+1]);\n        }\n\n        for (let i = 0, iMax = lines.length; i < iMax; i) {\n          pixel = latLonToPixel(lines[i++],lines[i++]);\n          vertexLines.push(pixel.x, pixel.y, chosenColor.r, chosenColor.g, chosenColor.b, chosenColor.a || opacity);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(e: ICanvasOverlayDrawEvent): this {\n    if (!this.gl) return this;\n\n    const { scale, offset, canvas } = e\n      , { mapMatrix, gl, vertices, settings, vertexLines } = this\n      ;\n\n    // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .setSize(canvas.width, canvas.height)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    // -- attach matrix value to 'mapMatrix' uniform in shader\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n    if (settings.border) {\n      const vertexLinesBuffer = this.getBuffer('vertexLines')\n        , vertexLinesTypedArray = new Float32Array(vertexLines)\n        , size = vertexLinesTypedArray.BYTES_PER_ELEMENT\n        , vertex = this.getAttributeLocation('vertex')\n        ;\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexLinesBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, vertexLinesTypedArray, gl.STATIC_DRAW);\n\n      if (this.settings.shaderVariables !== null) {\n        this.attachShaderVariables(size);\n      }\n\n      gl.vertexAttribPointer(vertex, 3, gl.FLOAT, false, size * this.bytes, 0);\n      gl.enableVertexAttribArray(vertex);\n      gl.enable(gl.DEPTH_TEST);\n      gl.viewport(0, 0, canvas.width, canvas.height);\n      gl.drawArrays(gl.LINES, 0, vertexLines.length / this.bytes);\n\n      const vertexBuffer = this.getBuffer('vertex')\n        , verticesTypedArray = new Float32Array(vertices)\n        ;\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, verticesTypedArray, gl.STATIC_DRAW);\n\n      if (settings.shaderVariables !== null) {\n        this.attachShaderVariables(size);\n      }\n\n      gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * this.bytes, 0);\n      gl.enableVertexAttribArray(vertex);\n      gl.enable(gl.DEPTH_TEST);\n      gl.viewport(0,0,canvas.width, canvas.height);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / this.bytes);\n\n    return this;\n  }\n\n  static tryClick(e: LeafletMouseEvent, map: Map): boolean {\n    let result\n      , settings\n      , feature\n      ;\n\n    Shapes.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      feature = _instance.polygonLookup.search(e.latlng.lng, e.latlng.lat);\n      if (feature) {\n        result = settings.click(e, feature);\n      }\n    });\n\n    return result !== undefined ? result : true;\n  }\n\n  static tryHover(e: LeafletMouseEvent, map: Map): boolean {\n    let result\n      , settings\n      , feature\n      ;\n\n    Shapes.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.hover) return;\n\n      feature = _instance.polygonLookup.search(e.latlng.lng, e.latlng.lat);\n\n      if (feature) {\n        result = settings.hover(e, feature);\n      }\n    });\n\n    return result !== undefined ? result : true;\n  }\n}\n","import { LeafletMouseEvent, Map } from 'leaflet';\n\nimport { Lines, ILinesSettings } from './lines';\nimport { Points, IPointsSettings } from './points';\nimport { IShapeSettings, Shapes } from './shapes';\nimport { debounce } from './utils';\n\n// @ts-ignore\nimport vertex from './shader/vertex/default.glsl';\n// @ts-ignore\nimport dot from './shader/fragment/dot.glsl';\n// @ts-ignore\nimport point from './shader/fragment/point.glsl';\n// @ts-ignore\nimport puck from './shader/fragment/puck.glsl';\n// @ts-ignore\nimport simpleCircle from './shader/fragment/simple-circle.glsl';\n// @ts-ignore\nimport square from './shader/fragment/square.glsl';\n// @ts-ignore\nimport polygon from './shader/fragment/polygon.glsl';\n\nconst shader = {\n  vertex,\n  fragment: {\n    dot,\n    point,\n    puck,\n    simpleCircle,\n    square,\n    polygon,\n  }\n};\n\nclass Glify {\n  longitudeKey: number = 1;\n  latitudeKey: number = 0;\n  maps: Map[] = [];\n  shader = shader;\n\n  Points: typeof Points = Points;\n  Shapes: typeof Shapes = Shapes;\n  Lines: typeof Lines = Lines;\n\n  longitudeFirst(): this {\n    this.longitudeKey = 0;\n    this.latitudeKey = 1;\n    return this;\n  }\n\n  latitudeFirst(): this {\n    this.latitudeKey = 0;\n    this.longitudeKey = 1;\n    return this;\n  }\n\n  get instances(): Array<Points | Lines | Shapes> {\n    return [\n      ...Points.instances,\n      ...Lines.instances,\n      ...Shapes.instances,\n    ];\n  }\n\n  points(settings: IPointsSettings): Points {\n    return new this.Points({\n      setupClick: glify.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: glify.latitudeKey,\n      longitudeKey: glify.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.point;\n      },\n      ...settings,\n    });\n  }\n\n  shapes(settings: IShapeSettings): Shapes {\n    return new this.Shapes({\n      setupClick: this.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings\n    });\n  }\n\n  lines(settings: ILinesSettings): Lines {\n    return new this.Lines({\n      setupClick: this.setupClick.bind(this),\n      setupHover: this.setupHover.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      ...settings\n    });\n  }\n\n  setupClick(map?: Map): void {\n    if (this.maps.indexOf(map) < 0) {\n      this.maps.push(map);\n      map.on('click', (e: LeafletMouseEvent) => {\n        let hit;\n        hit = Points.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Lines.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Shapes.tryClick(e, map);\n        if (hit !== undefined) return hit;\n      });\n    }\n  }\n\n  setupHover(map?: Map, hoverWait?: 250, immediate?: false): void {\n    this.maps.push(map);\n    map.on('mousemove', debounce((e: LeafletMouseEvent) => {\n      let hit;\n      hit = Points.tryHover(e, map);\n      if (hit !== undefined) return hit;\n\n      hit = Lines.tryHover(e, map);\n      if (hit !== undefined) return hit;\n\n      hit = Shapes.tryHover(e, map);\n      if (hit !== undefined) return hit;\n    }, hoverWait, immediate));\n  }\n}\n\nexport const glify = new Glify();\nexport default glify;\nif (typeof window !== 'undefined' && window.L) {\n  // @ts-ignore\n  window['L'].glify = glify;\n  // @ts-ignore\n  window['L'].Glify = Glify;\n}\n"]}